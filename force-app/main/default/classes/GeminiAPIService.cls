/**
 * GeminiAPIService
 * ----------------
 * A utility class responsible for making HTTP callouts to the Gemini API (via Named Credential).
 * 
 * Core Responsibilities:
 * - Accepts a prompt string and formats it for Gemini's generateContent API.
 * - Sends an authenticated HTTP POST request to the Gemini model.
 * - Parses the response to extract the generated text.
 * - Wraps the result in a structured GeminiResponse object, including error handling.
 * 
 * Usage in Anonymous Apex:
 *   GeminiAPIService.GeminiResponse result = GeminiAPIService.generateContent(promptString);
 *   if (result.success) {
 *       String generated = result.generatedText;
 *   } else {
 *       System.debug(result.errorMessage);
 *   }
 * 
 * Dependencies:
 * - Requires the Named Credential "GeminiAPINamedCredential"
 */

public class GeminiAPIService {

    // Inner class to represent the structured response from Gemini
    public class GeminiResponse {
        public String generatedText;   // The text generated by Gemini
        public Boolean success;        // Whether the API call succeeded
        public String errorMessage;    // Error message (if any)

        public GeminiResponse(Boolean success, String generatedText, String errorMessage) {
            this.success = success;
            this.generatedText = generatedText;
            this.errorMessage = errorMessage;
        }
    }

    /**
     * Sends a prompt to the Gemini API and returns the generated content.
     * 
     * @param customPrompt The prompt string to send to Gemini.
     * @return GeminiResponse containing either the generated text or an error.
     */
    public static GeminiResponse generateContent(String customPrompt) {
        try {
            // Step 1: Construct the request body in the expected Gemini format
            Map<String, Object> requestBody = new Map<String, Object>{
                'contents' => new List<Object>{
                    new Map<String, Object>{
                        'parts' => new List<Object>{
                            new Map<String, Object>{ 'text' => customPrompt }
                        }
                    }
                }
            };

            // Step 2: Configure HTTP request
            HttpRequest req = new HttpRequest();
            req.setEndpoint('callout:GeminiAPINamedCredential/v1beta/models/gemini-2.5-flash-lite:generateContent');
            req.setMethod('POST');
            req.setHeader('Content-Type', 'application/json');
            req.setBody(JSON.serialize(requestBody));

            // Step 3: Send the HTTP request
            HttpResponse res = new Http().send(req);

            // Step 4: Check for non-200 (error) response
            if (res.getStatusCode() != 200) {
                return new GeminiResponse(false, null, 'Gemini call failed: ' + res.getBody());
            }

            // Step 5: Parse the successful JSON response
            Map<String, Object> result = (Map<String, Object>) JSON.deserializeUntyped(res.getBody());
            List<Object> candidates = (List<Object>) result.get('candidates');
            
            if (candidates == null || candidates.isEmpty()) {
                return new GeminiResponse(false, null, 'No response from Gemini.');
            }

            // Step 6: Extract the generated text from the first candidate
            Map<String, Object> firstCandidate = (Map<String, Object>) candidates[0];
            Map<String, Object> content = (Map<String, Object>) firstCandidate.get('content');
            List<Object> parts = (List<Object>) content.get('parts');
            String geminiResolution = (String)((Map<String, Object>) parts[0]).get('text');

            // Step 7: Return the result in a structured response
            return new GeminiResponse(true, geminiResolution, null);

        } catch (Exception e) {
            // Handle any errors that occurred during the request or parsing
            return new GeminiResponse(false, null, 'Error during API call: ' + e.getMessage());
        }
    }
}